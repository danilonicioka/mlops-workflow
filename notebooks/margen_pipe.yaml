# PIPELINE DEFINITION
# Name: my-pipeline
# Inputs:
#    bucket_name: str
#    github_cloned_dir: str
#    github_main_branch: str
#    github_repo_url: str
#    github_token: str
#    github_username: str
#    k8s_api_token: str
#    kserve_namespace: str
#    minio_access_key: str
#    minio_secret_key: str
#    minio_url: str
components:
  comp-mar-gen:
    executorLabel: exec-mar-gen
    inputDefinitions:
      parameters:
        bucket_name:
          parameterType: STRING
        github_cloned_dir:
          parameterType: STRING
        github_main_branch:
          parameterType: STRING
        github_repo_url:
          parameterType: STRING
        github_token:
          parameterType: STRING
        github_username:
          parameterType: STRING
        k8s_api_token:
          parameterType: STRING
        kserve_namespace:
          parameterType: STRING
        minio_access_key:
          parameterType: STRING
        minio_secret_key:
          parameterType: STRING
        minio_url:
          parameterType: STRING
deploymentSpec:
  executors:
    exec-mar-gen:
      container:
        args:
        - --executor_input
        - '{{$}}'
        - --function_to_execute
        - mar_gen
        command:
        - sh
        - -c
        - "\nif ! [ -x \"$(command -v pip)\" ]; then\n    python3 -m ensurepip ||\
          \ python3 -m ensurepip --user || apt-get install python3-pip\nfi\n\nPIP_DISABLE_PIP_VERSION_CHECK=1\
          \ python3 -m pip install --quiet --no-warn-script-location 'kfp==2.7.0'\
          \ '--no-deps' 'typing-extensions>=3.7.4,<5; python_version<\"3.9\"'  &&\
          \  python3 -m pip install --quiet --no-warn-script-location 'gitpython'\
          \ 'kubernetes==30.1.0' 'Minio==7.2.5' && \"$0\" \"$@\"\n"
        - sh
        - -ec
        - 'program_path=$(mktemp -d)


          printf "%s" "$0" > "$program_path/ephemeral_component.py"

          _KFP_RUNTIME=true python3 -m kfp.dsl.executor_main                         --component_module_path                         "$program_path/ephemeral_component.py"                         "$@"

          '
        - "\nimport kfp\nfrom kfp import dsl\nfrom kfp.dsl import *\nfrom typing import\
          \ *\n\ndef mar_gen(\n    github_repo_url: str,\n    github_cloned_dir: str,\n\
          \    github_main_branch: str,\n    github_username: str,\n    github_token:\
          \ str,\n    minio_url: str,\n    minio_access_key: str,\n    minio_secret_key:\
          \ str,\n    kserve_namespace: str,\n    bucket_name: str,\n    k8s_api_token:\
          \ str\n):\n    from kubernetes import client, config, utils, watch\n   \
          \ import time\n    from kubernetes.client import Configuration\n    from\
          \ kubernetes.client.api import core_v1_api\n    from kubernetes.client.rest\
          \ import ApiException\n    from kubernetes.stream import stream\n    import\
          \ io\n    import tarfile\n    import pathlib\n    import os\n    from minio\
          \ import Minio\n    from git import Repo\n    from subprocess import run\n\
          \n    def clone_repository_with_token(github_repo_url, github_cloned_dir,\
          \ github_branch, github_username, github_token):\n        \"\"\"Clone a\
          \ Git repository using a GitHub token in the URL and specifying the branch.\"\
          \"\"\n        try:\n            # Construct the URL with the GitHub username\
          \ and token\n            url_with_token = f\"https://{github_username}:{github_token}@{github_repo_url.split('//')[1]}\"\
          \n\n            # Clone the repository from the specified branch\n     \
          \       repo = Repo.clone_from(url_with_token, github_cloned_dir, branch=github_branch)\n\
          \            return \"Repository cloned successfully\"\n        except Exception\
          \ as e:\n            return f\"Error occurred during repository cloning:\
          \ {e}\"\n\n    clone_result = clone_repository_with_token(github_repo_url,\
          \ github_cloned_dir, github_main_branch, github_username, github_token)\n\
          \n    # config.load_kube_config(\"kubeconfig\")\n    config.load_incluster_config()\n\
          \    k8s_client = client.ApiClient()\n    model_store_yaml_dir = f'{github_cloned_dir}/model-archiver/model-store-manifests/'\n\
          \n    try:\n        pv_result = utils.create_from_directory(k8s_client,\
          \ model_store_yaml_dir, verbose=True)\n    except Exception as e:\n    \
          \    print(e)\n\n    def wait_pod(core_v1, namespace, label, pod_name, time_in_sec):\n\
          \        w = watch.Watch()\n        for event in w.stream(func=core_v1.list_namespaced_pod,\n\
          \                                  namespace=namespace,\n              \
          \                    label_selector=label,\n                           \
          \       timeout_seconds=time_in_sec):\n            if event[\"object\"].status.phase\
          \ == \"Running\":\n                w.stop()\n                end_time =\
          \ time.time()\n                print(f\"{pod_name} running \")\n       \
          \         return\n            # event.type: ADDED, MODIFIED, DELETED\n \
          \           if event[\"type\"] == \"DELETED\":\n                # Pod was\
          \ deleted while we were waiting for it to start.\n                print(f\"\
          {pod_name} deleted before it started\")\n                w.stop()\n    \
          \            return\n\n    def exec_commands(api_instance, namespace, pod_name,\
          \ pod_container_name, command):\n        name = pod_name\n        resp =\
          \ None\n        try:\n            resp = api_instance.read_namespaced_pod(name=name,\n\
          \                                                    namespace=namespace)\n\
          \        except ApiException as e:\n            if e.status != 404:\n  \
          \              print(f\"Unknown error: {e}\")\n                exit(1)\n\
          \n        if not resp:\n            print(f\"Pod {name} does not exist.\"\
          )\n\n        # Calling exec and waiting for response\n        exec_command\
          \ = [\n            '/bin/sh',\n            '-c',\n            command]\n\
          \        # When calling a pod with multiple containers running the target\
          \ container\n        # has to be specified with a keyword argument container=<name>.\n\
          \        resp = stream(api_instance.connect_get_namespaced_pod_exec,\n \
          \             name=pod_name,\n              container=pod_container_name,\n\
          \              namespace=namespace,\n              command=exec_command,\n\
          \              stderr=True, stdin=False,\n              stdout=True, tty=False)\n\
          \        print(\"Response: \" + resp)\n\n    try:\n        c = Configuration().get_default_copy()\n\
          \    except AttributeError:\n        c = Configuration()\n        c.assert_hostname\
          \ = False\n    Configuration.set_default(c)\n    core_v1 = core_v1_api.CoreV1Api()\n\
          \n    # Create folders for model-store and config in PV\n    # kserve_namespace\
          \ = KSERVE_NAMESPACE\n    # model_store_pod_name = MODEL_STORE_POD_NAME\n\
          \    # model_store_pod_container_name = MODEL_STORE_POD_CONTAINER_NAME\n\
          \    model_store_pod_name = \"model-store-pod\"\n    model_store_pod_container_name\
          \ = \"model-store\"\n    model_store_pod_label = \"service.istio.io/canonical-name=model-store-pod\"\
          \n\n    # Wait for pods to run before exec\n    wait_pod(core_v1, kserve_namespace,\
          \ model_store_pod_label, model_store_pod_name, 120)\n\n    mkdir_ms_command\
          \ = \"mkdir /pv/model-store/\"\n    mkdir_ms_result = exec_commands(core_v1,\
          \ kserve_namespace, model_store_pod_name, model_store_pod_container_name,\
          \ mkdir_ms_command)\n    mkdir_conf_command = \"mkdir /pv/config/\"\n  \
          \  mkdir_conf_result = exec_commands(core_v1, kserve_namespace, model_store_pod_name,\
          \ model_store_pod_container_name, mkdir_conf_command)\n    mkdir_scripts_command\
          \ = \"mkdir /pv/scripts/\"\n    mkdir_scripts_result = exec_commands(core_v1,\
          \ kserve_namespace, model_store_pod_name, model_store_pod_container_name,\
          \ mkdir_scripts_command)\n\n    # Copy from or to pod\n    def copy_to_tar(source_path,\
          \ dest_path, tar):\n        \"\"\"\n        Adds a file or directory to\
          \ a tar archive.\n\n        Parameters:\n        - source_path: Path to\
          \ the source file or directory on the local machine.\n        - dest_path:\
          \ Destination directory inside the pod where files should be copied.\n \
          \       - tar: The tarfile object to which files and directories will be\
          \ added.\n        \"\"\"\n        source_path = pathlib.Path(source_path)\n\
          \n        if source_path.is_file():\n            # If it's a file, add to\
          \ the tarfile with the destination path\n            tar.add(source_path,\
          \ arcname=pathlib.Path(dest_path).joinpath(source_path.name))\n        elif\
          \ source_path.is_dir():\n            # If it's a directory, recursively\
          \ add all its content\n            for root, dirs, files in os.walk(source_path):\n\
          \                root_path = pathlib.Path(root)\n                # Compute\
          \ the relative path within the tar and add to destination path\n       \
          \         for file in files:\n                    file_path = root_path\
          \ / file\n                    tar.add(file_path, arcname=pathlib.Path(dest_path).joinpath(file_path.relative_to(source_path)))\n\
          \n    def extract_tar_to_local(tar_stream, dest_path):\n        \"\"\"\n\
          \        Extracts a tar archive stream to a local directory.\n\n       \
          \ Parameters:\n        - tar_stream: Tar stream from the pod.\n        -\
          \ dest_path: Local directory where the files will be extracted.\n      \
          \  \"\"\"\n        with tarfile.open(fileobj=tar_stream, mode='r:') as tar:\n\
          \            tar.extractall(path=dest_path)\n\n    def copy_file_or_dir(api_instance,\
          \ namespace, pod_name, pod_container_name, source_path, dest_path, to_pod=True):\n\
          \        \"\"\"\n        Copies a file or directory between a Kubernetes\
          \ pod and the local machine.\n\n        Parameters:\n        - api_instance:\
          \ Kubernetes API client instance.\n        - namespace: Namespace of the\
          \ pod.\n        - pod_name: Name of the pod.\n        - pod_container_name:\
          \ Name of the container within the pod.\n        - source_path: Path to\
          \ the source file or directory (local or in the pod).\n        - dest_path:\
          \ Destination directory (local or in the pod).\n        - to_pod: If True,\
          \ copy from local to pod; if False, copy from pod to local.\n        \"\"\
          \"\n        try:\n            if to_pod:\n                # Copying from\
          \ local to pod\n                buf = io.BytesIO()\n                with\
          \ tarfile.open(fileobj=buf, mode='w:tar') as tar:\n                    copy_to_tar(source_path,\
          \ dest_path, tar)\n\n                buf.seek(0)  # Reset buffer position\
          \ after writing tar\n\n                exec_command = ['tar', 'xvf', '-',\
          \ '-C', '/']\n                resp = stream(api_instance.connect_get_namespaced_pod_exec,\n\
          \                              pod_name,\n                             \
          \ namespace,\n                              container=pod_container_name,\n\
          \                              command=exec_command,\n                 \
          \             stderr=True, stdin=True, stdout=True, tty=False,\n       \
          \                       _preload_content=False)\n\n                # Send\
          \ tar file to pod\n                while resp.is_open():\n             \
          \       resp.update(timeout=1)\n                    if resp.peek_stdout():\n\
          \                        print(f\"STDOUT: {resp.read_stdout()}\")\n    \
          \                if resp.peek_stderr():\n                        print(f\"\
          STDERR: {resp.read_stderr()}\")\n                    if buf.getvalue():\n\
          \                        resp.write_stdin(buf.read())  # Write tar data\
          \ to pod\n                    else:\n                        resp.write_stdin('\\\
          n')  # Signal end of input\n                        break\n            \
          \    resp.close()\n\n            else:\n                # Copying from pod\
          \ to local\n                exec_command = ['tar', 'cvf', '-', source_path]\n\
          \                resp = stream(api_instance.connect_get_namespaced_pod_exec,\n\
          \                              pod_name,\n                             \
          \ namespace,\n                              container=pod_container_name,\n\
          \                              command=exec_command,\n                 \
          \             stderr=True, stdin=False, stdout=True, tty=False,\n      \
          \                        _preload_content=False)\n\n                tar_stream\
          \ = io.BytesIO()\n                while resp.is_open():\n              \
          \      resp.update(timeout=1)\n                    if resp.peek_stdout():\n\
          \                        tar_stream.write(resp.read_stdout().encode('utf-8'))\
          \  # Write stdout (tar) to stream\n                    if resp.peek_stderr():\n\
          \                        print(f\"STDERR: {resp.read_stderr()}\")\n\n  \
          \              tar_stream.seek(0)  # Reset stream position for extraction\n\
          \                extract_tar_to_local(tar_stream, dest_path)\n         \
          \       resp.close()\n\n        except Exception as e:\n            print(f\"\
          Error copying file or directory: {e}\")\n\n    model_store_source_path =\
          \ f'{github_cloned_dir}/model-archiver/model-store/'\n    model_store_dest_path\
          \ = \"/pv/model-store/\"\n\n    cp_ms_result = copy_file_or_dir(core_v1,\
          \ kserve_namespace, model_store_pod_name, model_store_pod_container_name,\
          \ model_store_source_path, model_store_dest_path, to_pod=True)\n\n    config_source_path\
          \ = f'{github_cloned_dir}/model-archiver/config/config.properties'\n   \
          \ config_dest_path = \"/pv/config/\"\n\n    cp_conf_result = copy_file_or_dir(core_v1,\
          \ kserve_namespace, model_store_pod_name, model_store_pod_container_name,\
          \ config_source_path, config_dest_path, to_pod=True)\n\n    # Delete model_store_pod\n\
          \    try:\n        api_response = core_v1.delete_namespaced_pod(model_store_pod_name,\
          \ kserve_namespace)\n        print(api_response)\n    except ApiException\
          \ as e:\n        print(\"Exception when calling CoreV1Api->delete_namespaced_pod:\
          \ %s\\n\" % e)\n\n    # Create model archiver pod\n    mar_yaml_dir = f'{github_cloned_dir}/model-archiver/manifests/'\n\
          \    # mar_pod_name = MAR_POD_NAME\n    # mar_pod_container_name = MAR_POD_CONTAINER_NAME\n\
          \    mar_pod_name = \"margen-pod\"\n    mar_pod_container_name = \"margen-container\"\
          \n    mar_pod_label = \"service.istio.io/canonical-name=margen-pod\"\n\n\
          \    try:\n        margen_result = utils.create_from_directory(k8s_client,\
          \ mar_yaml_dir, verbose=True)\n    except Exception as e:\n        print(e)\n\
          \n    # Wait for pods to run before exec\n    wait_pod(core_v1, kserve_namespace,\
          \ mar_pod_label, mar_pod_name, 120)\n\n    # Exec mar gen in a script\n\
          \    mar_gen_command = \"bash /home/model-server/scripts/margen.sh\"\n \
          \   mar_gen_result = exec_commands(core_v1, kserve_namespace, mar_pod_name,\
          \ mar_pod_container_name, mar_gen_command)\n\n    # Copy mar file to local\n\
          \    mar_source_path = \"youtubegoes5g.mar\"\n    mar_dest_path = \"./\"\
          \n\n    mar_cp_result = copy_file_or_dir(core_v1, kserve_namespace, mar_pod_name,\
          \ mar_pod_container_name, mar_source_path, mar_dest_path, to_pod=False)\n\
          \n    # Upload mar file to minio\n\n    def minio_setup(minio_url, minio_access_key,\
          \ minio_secret_key):\n        # Initialize Minio client with just the base\
          \ URL (without path)\n        client = Minio(\n            minio_url,  #\
          \ Ensure minio_url does not include a path, only the base URL (e.g., http://localhost:9000)\n\
          \            access_key=minio_access_key,\n            secret_key=minio_secret_key,\n\
          \            secure=False  # Minio is using HTTP on localhost:9000\n   \
          \     )\n        return client\n\n    def upload_file(client, bucket_name,\
          \ object_name, filepath):\n        # Create the bucket if it does not exist\n\
          \        if not client.bucket_exists(bucket_name):\n            client.make_bucket(bucket_name)\n\
          \            create_bucket_result = f\"Successfully created bucket: {bucket_name}\"\
          \n        else:\n            create_bucket_result = f\"Bucket {bucket_name}\
          \ already exists\"\n\n        try:\n            # Upload the file to the\
          \ specified path in the bucket\n            client.fput_object(bucket_name,\
          \ object_name, filepath)\n            return (f'Successfully uploaded {filepath}\
          \ to {bucket_name}/{object_name}')\n\n        except Exception as e:\n \
          \           # Log and raise any upload errors\n            raise Exception(f'Failed\
          \ to upload model to Minio: {e}')\n\n    # minio_url = MINIO_URL\n    #\
          \ minio_access_key = MINIO_ACCESS_KEY\n    # minio_secret_key = MINIO_SECRET_KEY\n\
          \n    client = minio_setup(minio_url, minio_access_key, minio_secret_key)\n\
          \n    # bucket_name = MINIO_MODEL_BUCKET_NAME\n    # mar_object_name = MAR_OBJECT_NAME\n\
          \    mar_object_name = \"model-store/youtubegoes5g.mar\"\n    mar_filepath\
          \ = './youtubegoes5g.mar'\n\n    up_mar_result = upload_file(client, bucket_name,\
          \ mar_object_name, mar_filepath)\n\n    # Delete margen pod\n    try:\n\
          \        api_response = core_v1.delete_namespaced_pod(mar_pod_name, kserve_namespace)\n\
          \        print(api_response)\n    except ApiException as e:\n        print(\"\
          Exception when calling CoreV1Api->delete_namespaced_pod: %s\\n\" % e)\n\n"
        image: python:3.11.9
pipelineInfo:
  name: my-pipeline
root:
  dag:
    tasks:
      mar-gen:
        cachingOptions:
          enableCache: true
        componentRef:
          name: comp-mar-gen
        inputs:
          parameters:
            bucket_name:
              componentInputParameter: bucket_name
            github_cloned_dir:
              componentInputParameter: github_cloned_dir
            github_main_branch:
              componentInputParameter: github_main_branch
            github_repo_url:
              componentInputParameter: github_repo_url
            github_token:
              componentInputParameter: github_token
            github_username:
              componentInputParameter: github_username
            k8s_api_token:
              componentInputParameter: k8s_api_token
            kserve_namespace:
              componentInputParameter: kserve_namespace
            minio_access_key:
              componentInputParameter: minio_access_key
            minio_secret_key:
              componentInputParameter: minio_secret_key
            minio_url:
              componentInputParameter: minio_url
        taskInfo:
          name: mar-gen
  inputDefinitions:
    parameters:
      bucket_name:
        parameterType: STRING
      github_cloned_dir:
        parameterType: STRING
      github_main_branch:
        parameterType: STRING
      github_repo_url:
        parameterType: STRING
      github_token:
        parameterType: STRING
      github_username:
        parameterType: STRING
      k8s_api_token:
        parameterType: STRING
      kserve_namespace:
        parameterType: STRING
      minio_access_key:
        parameterType: STRING
      minio_secret_key:
        parameterType: STRING
      minio_url:
        parameterType: STRING
schemaVersion: 2.1.0
sdkVersion: kfp-2.7.0
